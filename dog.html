<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Dog Runner ‚Äì Emoji Edition</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root {
      --w: 720px;
      --h: 240px;
      --groundY: 190px;
      --bg: #f7f7fb;
      --fg: #222;
      --accent: #3a86ff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0; min-height: 100vh; display: grid; place-items: center;
      background: linear-gradient(#ffffff, #eef3ff);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      color: var(--fg);
    }
    .wrap { width: min(95vw, var(--w)); }
    h1 { font-size: 20px; margin: 0 0 8px; text-align: center; }
    .hud {
      display: flex; justify-content: space-between; align-items: center;
      margin: 6px 0 10px; font-size: 14px;
    }
    .btn {
      border: 1px solid #cfd6ff; background: #fff; color: var(--accent);
      padding: 6px 10px; border-radius: 10px; cursor: pointer; font-weight: 600;
    }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .game {
      position: relative; width: 100%; height: var(--h); overflow: hidden;
      border: 2px solid #e0e6ff; border-radius: 14px; background: var(--bg);
      user-select: none; touch-action: manipulation;
    }
    .ground {
      position: absolute; left: 0; right: 0; top: var(--groundY);
      height: 4px; background: #d8defc;
      box-shadow: 0 1px 0 #c7cdf3 inset;
    }
    .dog, .obstacle, .cloud {
      position: absolute; font-size: 32px; line-height: 1;
      transform: translateZ(0);  /* hint to GPU */
    }
    .dog { left: 48px; top: calc(var(--groundY) - 32px); }
    .obstacle { bottom: calc(100% - var(--groundY)); }
    .cloud { top: 18px; opacity: 0.5; font-size: 28px; }
    .hint { text-align: center; font-size: 13px; opacity: .75; margin-top: 6px; }
    .flash { animation: flash 250ms ease; }
    @keyframes flash { from { background:#ffe8e8 } to { background: var(--bg) } }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>üêïüí® Dog Runner</h1>
    <div class="hud">
      <div>Score: <span id="score">0</span></div>
      <div>Best: <span id="best">0</span></div>
      <button id="startBtn" class="btn">Start</button>
    </div>
    <div id="game" class="game" aria-label="Dog Runner Game" tabindex="0">
      <div class="ground"></div>
      <div id="dog" class="dog" role="img" aria-label="Dog">üêï</div>
      <!-- clouds for fake depth -->
      <div class="cloud" style="left:140px">‚òÅÔ∏è</div>
      <div class="cloud" style="left:420px; top:40px">‚òÅÔ∏è</div>
      <div class="cloud" style="left:600px">‚òÅÔ∏è</div>
    </div>
    <div class="hint">Press Space or tap/click to jump. Avoid üåµ and üß±. Survive to score.</div>
  </div>

  <script>
    // Basic physics and loop
    const gameEl = document.getElementById('game');
    const dogEl = document.getElementById('dog');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const startBtn = document.getElementById('startBtn');

    const H = 240, groundY = 190, dogSize = 32;
    let playing = false, raf = 0, tPrev = 0;
    let dogY = groundY - dogSize, vy = 0, gravity = 1800, jumpV = -560;
    let obstacles = [];
    let speed = 320;         // px/sec base
    let spawnTimer = 0;      // time until next obstacle
    let score = 0, best = +localStorage.dogRunnerBest || 0;
    bestEl.textContent = best;

    function reset() {
      cancelAnimationFrame(raf);
      // Clear obstacles
      obstacles.forEach(o => o.el.remove());
      obstacles = [];
      // Reset dog
      dogY = groundY - dogSize; vy = 0;
      dogEl.style.top = `${dogY}px`;
      // Reset game vars
      speed = 320;
      spawnTimer = 0.5;
      score = 0;
      scoreEl.textContent = '0';
      gameEl.classList.remove('flash');
    }

    function start() {
      if (playing) return;
      reset();
      playing = true;
      startBtn.disabled = true;
      tPrev = performance.now();
      raf = requestAnimationFrame(loop);
    }

    function end() {
      playing = false;
      startBtn.disabled = false;
      gameEl.classList.add('flash');
      best = Math.max(best, Math.floor(score));
      localStorage.dogRunnerBest = best;
      bestEl.textContent = best;
      cancelAnimationFrame(raf);
    }

    function jump() {
      if (!playing) return;
      // Allow small coyote time: jump if near ground
      const nearGround = dogY >= groundY - dogSize - 6;
      if (nearGround) vy = jumpV;
    }

    function spawnObstacle() {
      const el = document.createElement('div');
      el.className = 'obstacle';
      // Randomize type
      const types = ['üåµ','üß±','ü™µ'];
      const emoji = types[Math.floor(Math.random() * types.length)];
      el.textContent = emoji;
      el.style.right = '-20px'; // start just off-screen
      el.style.fontSize = '28px';
      el.dataset.x = gameEl.clientWidth + 20; // logical x from left
      gameEl.appendChild(el);

      const width = 24, height = 28;
      obstacles.push({ el, x: gameEl.clientWidth + 20, w: width, h: height });
      // Next spawn window tightens gradually
      spawnTimer = 0.9 + Math.random() * 0.9;
      spawnTimer = Math.max(0.5, spawnTimer - (score / 250)); // harder over time
    }

    function loop(tNow) {
      const dt = Math.min(0.032, (tNow - tPrev) / 1000); // clamp delta
      tPrev = tNow;

      // Increase speed over time
      speed += 6 * dt;

      // Gravity update
      vy += gravity * dt;
      dogY += vy * dt;
      if (dogY > groundY - dogSize) {
        dogY = groundY - dogSize;
        vy = 0;
      }
      dogEl.style.top = `${dogY}px`;

      // Obstacle spawn
      spawnTimer -= dt;
      if (spawnTimer <= 0) spawnObstacle();

      // Move obstacles and detect collisions
      const toRemove = [];
      for (let i = 0; i < obstacles.length; i++) {
        const o = obstacles[i];
        o.x -= speed * dt;
        o.el.style.left = `${o.x}px`;

        // Collision (AABB)
        const dogX = 48, dogW = 24, dogH = 26;
        const dogTop = dogY, dogBottom = dogY + dogH;
        const oLeft = o.x, oRight = o.x + o.w;
        const oTop = groundY - o.h, oBottom = groundY;

        const overlapX = dogX < oRight && dogX + dogW > oLeft;
        const overlapY = dogBottom > oTop && dogTop < oBottom;
        if (overlapX && overlapY) {
          end();
          return; // stop loop
        }

        if (o.x + o.w < -10) toRemove.push(i);
      }
      // Cleanup passed obstacles
      for (let i = toRemove.length - 1; i >= 0; i--) {
        const idx = toRemove[i];
        obstacles[idx].el.remove();
        obstacles.splice(idx, 1);
      }

      // Score
      score += dt * 10;
      scoreEl.textContent = Math.floor(score);

      raf = requestAnimationFrame(loop);
    }

    // Controls
    startBtn.addEventListener('click', start);
    gameEl.addEventListener('pointerdown', jump);
    window.addEventListener('keydown', e => {
      if (e.code === 'Space') { e.preventDefault(); jump(); }
      if (e.code === 'Enter' && !playing) start();
    });

    // Accessibility: focus for keyboard on first load
    gameEl.addEventListener('click', () => gameEl.focus());
  </script>
</body>
</html>
